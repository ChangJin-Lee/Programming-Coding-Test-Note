
## Programming-Coding-Test-Note

* This repository is a Coding test library.
* if you need an explanation of a specific algorithm, please contact me.
* 알고리즘 문제를 해결하기 위한 소스코드 저장소입니다.
* 파이썬, C, C++, Java, Swift 를 사용하여 문제를 해결했습니다.

---
## Contents

### Sorting

* [counting sort](/Sorting/bj10989_수정렬3.py)

### Searching

* [Binary Search](/BinarySearch/bj10816_숫자카드2.py)
* [Binary Search2](/BinarySearch/bj2805_나무자르기.py)

* DFS - BFS
    * [Using dequeue](/BFS-DFS/프로그래머스_네트워크_DFS_BFS.py)
    * [DFS & BFS Examples 1](/BFS-DFS/bj7562_나이트의이동.py)

### Graph

* [Dijkstra Shortest Path](/Dijkstra/bj1719_택배.py)
* [Floyd Warshall algorithm(플루이드 와샬)](/Graph/bj2660_회장뽑기.py)

### Data Structure

* [Tree](/Tree/bj1991_트리순회.py)
* [Stack](/Stack/bj6051_시간여행.py)
* [Queue](/Queue/프로그래머스_프린터.py)

<!-- ### String

* Rabin-Karp
* KMP
* Trie -->

### Dynamic Programming

- 분할정복 즉 Divide and conquer 에서는 풀었던 문제를 다시 반복해서 풀지만 다이나믹 프로그래밍에서는 단 한번만 문제를 푼다. 내가 이해한 다이나믹 프로그래밍의 핵심은 다음과 같다. "현재 상태를 기억하고 그 상태를 계속해서 갱신해 나간다" 메모이제이션 방법이며 풀었던 문제는 풀지 않는다. 그리디 방법이나 분할정복으로는 풀리지 않는 문제들이 다이나믹 프로그래밍으로는 정말 쉽게 풀린다.

* [DP](/DynamicProgramming/bj2565_전깃줄.py)

<!-- * Tiling Problem
* 0-1 Knapsack Problem
* LIS (Longest Increasing Subsequence)
* LCS (Longest Common Subsequence)
* Matrix Chain Multiplication -->

<!-- ### Geometry

* [Number of intersection points of two lines in 1 dimension](/Geometry/number_of_intersection_points_of_two_lines_in_1_dimension.py)
* CCW
* Convex Hull
* Polygon -->

### BackTracking 
- 백트레킹은 모든 경우의 수를 찾아보는 방법이다. 유명한 문제로는 체스판 위에 퀸을 움직이는 경우의 수이다.
- "모든 경우의 수 중에서 원하는 조건에 해당하는 경우의 수만을 계산하겠다."
#### Probability Theory

* [Permutation](/BackTracking/bj15649_N과M1.py)
* [Permutation](/BackTracking/bj14888_연산자끼워넣기.py)
* [Combination](/BackTracking/bj15649_N과M2.py)

### Number Theory

<!-- * [GCD (Greatest Common Divisor)](/Number%20Theory/gcd.py)
* [LCM (Least Common Multiple)](/Number%20Theory/lcm.py)
* [Check Prime Number](/Number%20Theory/is_prime_number.py)
* [Find All Divisors](/Number%20Theory/find_all_divisors_of_a_number.py) -->
* [Prime Factorization](/Math/bj2581_소수.py)
* [Sieve of Eratosthenes](/Math/bj1929_소수구하기.py)
<!-- 
### Signal Processing

* FFT

### Miscellaneous

* Two Pointers
    * [Number of intervals whose sum is M](/Miscellaneous/number_of_intervals_whose_sum_is_M.py)
* Interval Sum
    * [Prefix Sum](/Miscellaneous/prefix_sum.py)
    * [Fenwick Tree (Binary Indexed Tree)](/Miscellaneous/fenwick_tree.py)
* [Matrix Rotation](/Miscellaneous/rotate_a_matrix_by_90_degree.py)
* Handling Recursion Limit -->